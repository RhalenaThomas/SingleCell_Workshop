---
title: "R Notebook for scRNAseq workkshop 2025-Part1"
Presenter: Moein Yaqubi
output: html_notebook
---

section 1: 
1. Loading data
2. Quality Control
   2.1 Cell filtering
   2.2 empty droplets removal
   2.3 ambient RNA removal

# Analysis workflow

Load your required libraries.
This workflow requires specific R libraries to be installed. While we've already installed the necessary packages on the Magic Castle accounts for the workshop to ensure a seamless run, please note that you'll need to install them on your personal computers, servers, or Compute Canada clusters to use the workflow elsewhere. 

```{r}
rm(list = ls())

library(Seurat)
library(SoupX)
#library(DropletQC)
```

Load the data. For this workshop we are using the data provided by this paper:


The original study characterized the transcriptional profiles of human brain samples from both Parkinson's disease patients and control donors. For our workshop, we specifically downloaded four of the control samples' FASTQ files and processed them through the Cell Ranger pipeline (CTRL1-4). You will be working directly with the resulting Cell Ranger output from these four samples. 

To analyze the single-cell RNA-seq data, including creating a Seurat object, removing ambient RNA, and identifying/removing empty droplets, you'll need the following input files. These are all generated by the Cell Ranger pipeline:

1- Filtered gene-barcode matrix
2- Raw gene-barcode matrix
3- BAM file and its index file


If you choose not to correct your data for ambient RNA or remove empty droplets, you can simplify your input. In this case, you only need the filtered gene-barcode matrix as your primary input for Seurat, and you can disregard the other files.

1) Set working directory & load 10× data

```{r}
# set you directory to be where
filtered_CTRL1 <- Read10X(data.dir = "CTRL1_filtered_feature_bc_matrix")
raw_CTRL1      <- Read10X(data.dir = "CTRL1_raw_feature_bc_matrix")
```


```{r}
# 2) Build Seurat object on filtered counts
CTRL1 <- CreateSeuratObject(counts  = filtered_CTRL1, project = "CTRL1")
```

Calculate the percentage of mitochondrial gene expression for each cell in the 'CTRL1' object. This serves as a key QC metric: cells with high mitochondrial read percentages often indicate low-quality or dying cells, which we may want to filter out before downstream analyses.
The [[ operator can add columns to object metadata.

```{r}
CTRL1[["percent.mt"]] <- PercentageFeatureSet(CTRL1, pattern = "^MT-")
```


Normalize the data. Seurat’s default “LogNormalize” method

1. For each cell, take the raw count for a given gene and divide it by the sum of all gene counts in that same cell—i.e., you convert each gene’s count into a fraction of that cell’s total counts.

2. Multiplies by the chosen scale factor (10,000),

3. Then applies a natural log transform (log1p, i.e. log(x + 1)).

```{r}
CTRL1 <- NormalizeData(CTRL1, normalization.method = "LogNormalize", scale.factor = 10000)
```

To remove ambient RNA, SoupX (and similar tools) need a preliminary clustering of cells.
That clustering step requires running the full Seurat preprocessing pipeline below—
though we will explain each function in detail during the next workshop session.
For now, please go ahead and run these commands so that the object is ready for ambient RNA removal:

```{r}
CTRL1 <- FindVariableFeatures(CTRL1, selection.method = "vst", nfeatures = 2000)
CTRL1 <- ScaleData(CTRL1)
CTRL1 <- RunPCA(CTRL1, dims = 1:30, verbose = FALSE)
CTRL1 <- RunUMAP(CTRL1, dims = 1:30, verbose = FALSE)
CTRL1 <- FindNeighbors(CTRL1, dims = 1:30)
CTRL1 <- FindClusters(CTRL1, resolution = 0.4)
```

Build the SoupChannel object & assign clusters/DR coordinates
SoupChannel integrates two count matrices:
• tod (table of droplets) = raw unfiltered counts (may include ambient RNA)
• toc (table of counts)   = filtered counts (cells retained after QC)
The resulting SoupChannel object (sc) stores both raw and filtered data,
which SoupX uses to estimate ambient RNA contamination per cell cluster.

# raw (unfiltered) UMI count matrix
# filtered UMI count matrix (only high‐quality cells)

```{r}
sc <- SoupChannel(tod = raw_CTRL1, toc = filtered_CTRL1)

```

This will creaete and object and add in a nUMIs by barcode slot called metaData
You will calculate the ambiant RNA background

Next, tell SoupX which cluster each cell belongs to. Here, we use the Seurat clustering
results stored in CTRL1$seurat_clusters. `setNames(…, Cells(CTRL1))` ensures that the
cluster vector is named by each cell’s barcode.

```{r}
sc <- setClusters(sc, setNames(CTRL1$seurat_clusters, Cells(CTRL1)))
```

Provide dimensionality reduction (UMAP) coordinates so SoupX can use spatial relationships
between cells if desired. This pulls the UMAP embeddings from the Seurat object.

```{r}
sc <- setDR(sc, CTRL1@reductions$umap@cell.embeddings)
```

Estimate ambient contamination & adjust counts
autoEstCont() runs SoupX’s built‐in contamination estimation, which:
• Estimates how much “soup” (ambient RNA) contributed to each cluster
• Learns a contamination fraction per cell
The returned `sc` object now contains this estimated contamination information.
```{r}
sc <- autoEstCont(sc)
```


adjustCounts() uses the estimated contamination fractions to subtract ambient RNA
from each cell’s expression profile, returning a “clean” count matrix. By setting
roundToInt = TRUE, the adjusted counts are rounded back to integers (UMIs).

```{r}
clean_mat <- adjustCounts(sc, roundToInt = TRUE)
```


After this step, `clean_mat` holds the decontaminated UMI counts for each cell.
Now we overwrite Seurat’s counts with SoupX‐corrected matrix

```{r}
CTRL1 <- SetAssayData(CTRL1, assay = "RNA", layer = "counts", new.data = clean_mat)
```



Compute the nuclear‐fraction for each cell in the SoupX‐cleaned dataset
The nuclear_fraction_tags() function uses aligned BAM data to estimate, for each barcode,
what fraction of reads map to intronic (nuclear) regions versus exonic (cytoplasmic) regions.
High nuclear fraction can indicate ambient RNA or low‐quality cells, so we compute this metric here.
Read in the list of cell barcodes that passed filtering (same barcodes used in the filtered count matrix)

```{r}
barcodes <- readLines("CTRL1_filtered_feature_bc_matrix/barcodes.tsv.gz")
```


Run the nuclear_fraction_tags() function:
 • bam: path to the CellRanger‐generated positional BAM file (“possorted_genome_bam.bam”).
 • barcodes: vector of cell barcode strings to process.
 • tiles: number of tiles to split each BAM into for parallel processing (100 here).
 • cores: number of CPU cores to use for parallelization (4 here).
 • verbose: print progress messages to the console.
 
```{r}
nf <- nuclear_fraction_tags(bam = "possorted_genome_bam_CTRL1.bam", barcodes = barcodes, 
                            tiles = 100, cores  = 4, verbose  = TRUE)
```


The result “nf” is a data frame (or matrix) with one row per barcode and columns like “nuclear_fraction”,
indicating the fraction of reads derived from nuclear (intronic) regions for that cell.

Add the nuclear_fraction as a new metadata column in our Seurat object (CTRL1).
We index nf by the Seurat cell names (colnames(CTRL1)) to ensure correct alignment.

```{r}
CTRL1$nuclear_fraction <- nf[colnames(CTRL1), "nuclear_fraction"]
```

Identify and remove empty droplets based on nuclear fraction and UMI count
DropletQC’s identify_empty_drops() function flags barcodes as “cell” vs “empty” based on QC thresholds.
We combine nuclear fraction and total UMI counts (nCount_RNA) into a data frame for this.

Build a data frame with each cell’s nuclear fraction and UMI count:

```{r}
qc_df <- data.frame(
  nuclear_fraction = CTRL1$nuclear_fraction,  # fraction of intronic (nuclear) reads
  umi              = CTRL1$nCount_RNA         # total UMI count per cell
)

```

Run identify_empty_drops() to classify each barcode:
• nf_umi: data frame of nuclear_fraction and umi for each barcode.
• nf_rescue: nuclear_fraction cutoff—cells with nuclear_fraction ≥ 0.05 are “rescued” from being
                flagged as empty if they have high UMI. (Set at 0.05 here.)
• umi_rescue: UMI‐count cutoff—cells with umi ≥ 1000 are rescued from being flagged empty,
                even if nuclear_fraction is high. (Set at 1000 here.)
• include_plot: TRUE generates a diagnostic plot of nuclear_fraction vs umi with cutoffs.

```{r}
empty_qc <- identify_empty_drops(
  nf_umi       = qc_df,
  nf_rescue    = 0.05,
  umi_rescue   = 1000,
  include_plot = TRUE)
```


Store the “cell_status” (“cell” vs “empty”) output from identify_empty_drops as new metadata

```{r}
CTRL1$droplet_qc <- empty_qc$cell_status
```


Subset the Seurat object to keep only droplets classified as “cell”

```{r}
CTRL1 <- subset(CTRL1, subset = droplet_qc == "cell")
```


visualize QC metrics, and use these to filter cells in the later step.

```{r}
# Visualize QC metrics as a violin plot
VlnPlot(CTRL1, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
```

Below we filter out low‐quality and outlier cells based on three common QC metrics:

nFeature_RNA: Number of genes detected in each cell.

percent.mt: Percentage of mitochondrial gene counts (calculated previously).
Because every dataset has its own distribution of gene counts and mitochondrial content, there is no single “right” threshold. Instead, you inspect violin or scatter plots of these metrics (e.g., VlnPlot(pbmc, features = c("nFeature_RNA", "percent.mt"))) and choose cutoffs that remove obvious outliers. In this example, we keep only cells that satisfy:

200 < nFeature_RNA < 10000 (i.e., at least 200 genes detected but fewer than 10000),

percent.mt < 10 (fewer than 5% of reads from mitochondrial genes).
```{r}

CTRL1 <- subset(CTRL1, subset = nFeature_RNA > 200 & nFeature_RNA < 10000 & percent.mt < 10)
```

```{r}
# Process only the remaining three samples (CTRL2, CTRL3, CTRL4).
# Each iteration reads in filtered & raw matrices, creates a Seurat object,
# removes ambient RNA, filters empty droplets, and removes low‐quality cells.

samples <- c("CTRL2", "CTRL3", "CTRL4")

for (samp in samples) {
  
  message("—————— Processing: ", samp, " ——————")
  
  # 1) Ensure working directory is set
  setwd("C:/Users/labuser/Downloads/Moein/Workshop_2025")
  
  # 2) Read in filtered and raw 10× data for this sample
  filtered_counts <- Read10X(data.dir = paste0(samp, "_filtered_feature_bc_matrix"))
  raw_counts      <- Read10X(data.dir = paste0(samp, "_raw_feature_bc_matrix"))
  
  # 3) Build a Seurat object on filtered counts
  seu <- CreateSeuratObject(counts = filtered_counts, project = samp)
  
  # 4) Calculate percentage of mitochondrial gene expression
  seu[["percent.mt"]] <- PercentageFeatureSet(seu, pattern = "^MT-")
  
  # 5) Normalize data (LogNormalize: counts → scaled to 10k → log1p)
  seu <- NormalizeData(seu, normalization.method = "LogNormalize", scale.factor = 10000)
  
  # 6) Quick clustering so SoupX can estimate ambient RNA contamination
  seu <- FindVariableFeatures(seu, selection.method = "vst", nfeatures = 2000)
  seu <- ScaleData(seu)
  seu <- RunPCA(seu, dims = 1:30, verbose = FALSE)
  seu <- RunUMAP(seu, dims = 1:30, verbose = FALSE)
  seu <- FindNeighbors(seu, dims = 1:30)
  seu <- FindClusters(seu, resolution = 0.4)
  
  # 7) Build SoupChannel & assign clusters / UMAP coordinates
  sc <- SoupChannel(tod = raw_counts, toc = filtered_counts)
  cluster_vec <- seu$seurat_clusters
  names(cluster_vec) <- Cells(seu)
  sc <- setClusters(sc, cluster_vec)
  sc <- setDR(sc, seu@reductions$umap@cell.embeddings)
  
  # 8) Estimate and remove ambient contamination
  sc        <- autoEstCont(sc)
  clean_mat <- adjustCounts(sc, roundToInt = TRUE)
  seu <- SetAssayData(seu, assay = "RNA", layer = "counts", new.data = clean_mat)
  
  # 9) Compute nuclear fraction on SoupX‐corrected data
  barcodes <- readLines(paste0(samp, "_filtered_feature_bc_matrix/barcodes.tsv.gz"))
  nf <- nuclear_fraction_tags(
    bam      = paste0("possorted_genome_bam_", samp, ".bam"),
    barcodes = barcodes,
    tiles    = 100,
    cores    = 4,
    verbose  = TRUE
  )
  seu$nuclear_fraction <- nf[colnames(seu), "nuclear_fraction"]
  
  # 10) Identify & remove empty droplets based on nuclear fraction + UMI count
  qc_df <- data.frame(
    nuclear_fraction = seu$nuclear_fraction,
    umi              = seu$nCount_RNA
  )
  empty_qc <- identify_empty_drops(
    nf_umi       = qc_df,
    nf_rescue    = 0.05,
    umi_rescue   = 1000,
    include_plot = TRUE
  )
  seu$droplet_qc <- empty_qc$cell_status
  seu <- subset(seu, subset = droplet_qc == "cell")
  
  # 11) Visualize QC metrics (optional)
  print(
    VlnPlot(
      seu,
      features = c("nFeature_RNA", "nCount_RNA", "percent.mt"),
      ncol     = 3
    )
  )
  
  # 12) Final filtering: keep cells with 200 < nFeature_RNA < 10000 and percent.mt < 10
  seu <- subset(
    seu,
    subset = nFeature_RNA > 200 &
             nFeature_RNA < 10000 &
             percent.mt   < 10
  )
  
  # 13) Save cleaned object under the sample name
  assign(samp, seu)
  
  message("—————— Finished: ", samp, " ——————")
  message("\n")
}

```

Next, we’ll clear out all intermediate objects from our environment and retain only the four final Seurat objects for downstream analyses

we define the names of the final Seurat objects you want to keep
then we list everything currently in the global environment
then determine which objects to remove (i.e., everything except the four Seurat objects)
finally we remove those intermediate objects

```{r}
keep_objs <- c("CTRL1", "CTRL2", "CTRL3", "CTRL4")
all_objs <- ls()
objs_to_remove <- setdiff(all_objs, keep_objs)
rm(list = objs_to_remove)

```


At the final step, we need to prepare a “clean” object for tomorrow’s session with Rhalena. By “clean,” I mean we will generate new CTRL1_clean, CTRL2_clean, CTRL3_clean, and CTRL4_clean objects by stripping out all precomputed reductions, neighbor graphs, and clustering metadata. This allows Rhalena to walk through the code step by step—re‐running PCA, UMAP, FindNeighbors, and FindClusters—instead of reviewing already‐saved results. All of the ambient RNA removal, empty‐droplet filtering, and low‐quality‐cell filtering steps remain intact.


```{r}
# List of original Seurat objects to clean (we skip CTRL1 since it already exists)
orig_samples <- c("CTRL1", "CTRL2", "CTRL3", "CTRL4")

for (samp in orig_samples) {
  # Retrieve the existing Seurat object
  seu_orig <- get(samp)
  
  # Make a copy and give it a new name with "_clean" suffix
  clean_name <- paste0(samp, "_clean")
  seu_clean <- seu_orig
  
  # 1) Remove all existing dimensionality reductions
  seu_clean@reductions <- list()
  
  # 2) Remove any neighbor/graph information
  seu_clean@graphs    <- list()
  seu_clean@neighbors <- list()
  seu_clean@commands  <- list()
  
  # 3) Drop clustering metadata columns (e.g., seurat_clusters, seurat_snn_*)
  md <- seu_clean@meta.data
  cols_to_remove <- grep("^seurat_(clusters|snn)", colnames(md), value = TRUE)
  if (length(cols_to_remove) > 0) {
    md <- md[, setdiff(colnames(md), cols_to_remove), drop = FALSE]
    seu_clean@meta.data <- md
  }
  
  # 4) Assign the cleaned object into the global environment under the new name
  assign(clean_name, seu_clean)
  message("Created cleaned object: ", clean_name)
}

```



```{r}

```

